diff --git a/musl-cross-make-master/musl-1.1.14/src/env/__libc_start_main.c b/musl-1.1.14/src/env/__libc_start_main.c
index 5c79be2..35e0165 100644
--- a/musl-cross-make-master/musl-1.1.14/src/env/__libc_start_main.c
+++ b/musl-1.1.14/src/env/__libc_start_main.c
@@ -6,6 +6,8 @@
 #include "atomic.h"
 #include "libc.h"
 
+int __sgxbounds_caninstrument = 0;
+
 void __init_tls(size_t *);
 
 static void dummy(void) {}
@@ -63,14 +65,420 @@ static void libc_start_init(void)
 
 weak_alias(libc_start_init, __libc_start_init);
 
-int __libc_start_main(int (*main)(int,char **,char **), int argc, char **argv)
+int orig__libc_start_main(int (*main)(int,char **,char **), int argc, char **argv)
 {
 	char **envp = argv+argc+1;
 
 	__init_libc(envp, argv[0]);
+    __sgxbounds_caninstrument = 1;
 	__libc_start_init();
+    __sgxbounds_caninstrument = 0;
 
 	/* Pass control to the application */
 	exit(main(argc, argv, envp));
 	return 0;
 }
+
+/* =============================================================== PRELOAD */
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <errno.h>
+#include <assert.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <sys/syscall.h>
+#include <sys/mman.h>
+#include <sys/resource.h>
+#include <sys/prctl.h>
+
+#define ARCH_SET_FS 0x1002
+#define ARCH_GET_FS 0x1003
+
+/* Not defined in glibc */
+int arch_prctl(int code, unsigned long *addr);
+
+
+/* How many bits should our new addr space be reduced to? */
+#define REDUCED_ADDRSPACE_SIZE (1ULL << 32)
+
+
+#define KERN_ADDRSPACE (1ULL << 47) /* Top of our (mmap-able) addr space */
+
+#define DEBUG
+#ifdef DEBUG
+#define debug_print(...) fprintf(stderr, " # " __VA_ARGS__)
+#else
+#define debug_print(...) do { } while(0)
+#endif
+
+typedef int (*main_t)(int, char **, char **);
+static main_t orig_main;
+
+#define PROCMAP_TYPE_UNKNOWN    0x00
+#define PROCMAP_TYPE_FILE   0x01
+#define PROCMAP_TYPE_ANONYMOUS  0x02
+#define PROCMAP_TYPE_HEAP   0x03
+#define PROCMAP_TYPE_STACK  0x04
+#define PROCMAP_TYPE_VSYSCALL   0x05
+#define PROCMAP_TYPE_VDSO   0x06
+
+struct procmap_entry {
+    uintptr_t   begin;
+    uintptr_t   end;
+    uint64_t    offset;
+    char        r; // Readable
+    char        w; // Writable
+    char        x; // Executable
+    char        p; // Private (or shared)
+    char        path[256];
+    int         type;
+};
+
+
+/*
+ * Often we are put in the environment too early, and thus we're preloaded for
+ * wrapper scripts and such. These programs (e.g., dash) are not prelinked and
+ * thus cannot run with this library. As such, we whitelist certain programs.
+ * Anything in [/usr]/bin cannot be prelinked (or shouldn't be).
+ */
+int whitelisted_program(char *program)
+{
+    if (strstr(program, "specinvoke"))
+        return 1;
+    if (strstr(program, "strace"))
+        return 1;
+    if (!strncmp(program, "/bin/", 5))
+        return 1;
+    if (!strncmp(program, "/usr/", 5))
+        return 1;
+
+    return 0;
+}
+
+/*
+ * This functions sets up a new stack using the information
+ * contained in the old one. It returns the new stack address
+ */
+void setup_new_stack(char **ubp_av, uintptr_t new_stack_top,
+        uintptr_t *new_stack_ptr, uintptr_t *new_ubp)
+{
+    /**
+     * ------------------------------
+     *  [ 0 ]  <-- top of the stack
+     *  [ envp strings ]
+     *  [ argv strings ]
+     *  [ 0 ]
+     *  [ auxv ]
+     *  [ 0 ]
+     *  [ envp ]
+     *  [ 0 ]
+     *  [ argv ]
+     *  [ argc ] <-- stack pointer
+     * -----------------------------
+     **/
+
+    /* Strategy: locate top of the stack copy values over and than adjust
+     * pointers of envp, and argv. */
+    char **stack_top_tmp = ubp_av;
+    char *last_string = 0;
+
+    /* ARGV (Pointer to arguments)*/
+    while (*stack_top_tmp != 0) {
+        if (last_string < *stack_top_tmp) {
+            last_string = *stack_top_tmp;
+        }
+        stack_top_tmp++;
+    }
+
+    stack_top_tmp++;
+
+    /* env */
+    environ = stack_top_tmp;
+
+    while (*stack_top_tmp != 0) {
+        if (last_string < *stack_top_tmp) {
+            last_string = *stack_top_tmp;
+        }
+        stack_top_tmp++;
+    }
+
+    /* go to end of last string.*/
+    while (*last_string++ != 0);
+
+    /* there seems to be another string on the stack */
+    while (*last_string++ != 0);
+
+    /* the stack should end here... */
+    uintptr_t top_of_stack = (uintptr_t)last_string;
+
+    /* actually here: */
+    top_of_stack = (top_of_stack + 0x3) & ~(0x3);
+
+    /* check for top stack marker */
+    if (*(uintptr_t *)top_of_stack != 0) {
+        fprintf(stderr, "ERROR: couldn't locate top of the stack\n");
+        exit(1);
+    }
+
+    uintptr_t stack_offset = top_of_stack + sizeof(uintptr_t) - new_stack_top;
+
+    /* fix the pointers to the new argv and env values */
+    char **tmp = ubp_av;
+
+    while (*tmp != 0)
+        *tmp++ -= stack_offset; /* for argvs */
+
+    tmp++;
+
+    while (*tmp != 0)
+        *tmp++ -= stack_offset; /* ... and for envs */
+
+    /* now we can copy the stack */
+
+    uintptr_t from = (uintptr_t)ubp_av - sizeof(uintptr_t); /* argc */
+
+    size_t stack_size = top_of_stack - from;
+
+    uintptr_t *newstack =
+        (void *)((uintptr_t)new_stack_top - sizeof(uintptr_t) - stack_size);
+
+    memcpy((void *)newstack, (void *)from, stack_size);
+
+    /* now that we have done that we have to prepare the new statck for
+       __libc_start_main */
+
+    /* first it wants garbage */
+    newstack--;
+    newstack--;
+
+    environ = (void *)(((uintptr_t)environ) - stack_offset);
+    *new_stack_ptr = (uintptr_t)newstack;
+    *new_ubp = (uintptr_t)ubp_av - stack_offset;
+}
+
+
+static int procmap_get_type(const char *path)
+{
+    if (path[0] != '[' && path[0] != '\0')
+        return PROCMAP_TYPE_FILE;
+    if (path[0] == '\0')
+        return PROCMAP_TYPE_ANONYMOUS;
+    if (strcmp(path, "[heap]") == 0)
+        return PROCMAP_TYPE_HEAP;
+    if (strncmp(path, "[stack", 6) == 0)
+        return PROCMAP_TYPE_STACK;
+    if (strcmp(path, "[vsyscall]") == 0)
+        return PROCMAP_TYPE_VSYSCALL;
+    if (strcmp(path, "[vdso]") == 0)
+        return PROCMAP_TYPE_VDSO;
+    return PROCMAP_TYPE_UNKNOWN;
+}
+
+size_t procmap_parse(struct procmap_entry *entries, size_t num_entries)
+{
+    FILE *map;
+    struct procmap_entry *entry;
+    unsigned int dev1, dev2, inode;
+    char read, write, execute, private;
+    char line[512];
+    char path[256];
+    size_t i = 0;
+
+    map = fopen("/proc/self/maps", "r");
+    if (map == NULL) {
+        fprintf(stderr, "Could not open /proc/self/maps!\n");
+        abort();
+    }
+
+    setvbuf(map, NULL, _IOFBF, 8192);
+
+    while (!feof(map)) {
+        if (i == num_entries)
+            break;
+        entry = &entries[i];
+
+        path[0] = '\0';
+        if (fgets(line, 512, map) == NULL)
+            break;
+        sscanf((char *)&line, "%lx-%lx %c%c%c%c %lx %x:%x %d %s",
+              &entry->begin, &entry->end,
+              &read, &write, &execute, &private, &entry->offset,
+              &dev1, &dev2, &inode, path);
+        entry->r = (read == 'r');
+        entry->w = (write == 'w');
+        entry->x = (execute == 'x');
+        entry->p = (private == 'p');
+        strncpy(entry->path, path, 256);
+        entry->type = procmap_get_type(path);
+
+        i++;
+    }
+    fclose(map);
+    return i;
+}
+
+void procmap_dump(struct procmap_entry *entries, size_t num_entries)
+{
+    (void)entries;
+    size_t i;
+    debug_print("--- Process Map Dump ---\n");
+    debug_print("addr range                            perm offset    path\n");
+    for (i = 0; i < num_entries; i++)
+        debug_print("0x%016lx-0x%016lx %c%c%c%c %08lx %s\n",
+                entries[i].begin, entries[i].end,
+                entries[i].r ? 'R' : '-',
+                entries[i].w ? 'W' : '-',
+                entries[i].x ? 'X' : '-',
+                entries[i].p ? 'P' : 'S',
+                entries[i].offset,
+                entries[i].path);
+}
+
+
+void fill_high_holes(void)
+{
+    struct procmap_entry procmap[255];
+    size_t procmap_entries;
+    size_t i;
+    uintptr_t prev_end = 0;
+    procmap_entries = procmap_parse(procmap, 255);
+    procmap_dump(procmap, procmap_entries);
+    for (i = 0; i < procmap_entries; i++)
+        if (procmap[i].begin > REDUCED_ADDRSPACE_SIZE && procmap[i].begin < KERN_ADDRSPACE) {
+            size_t sz = procmap[i].begin - prev_end;
+            if (prev_end && sz) {
+                void *tmp;
+                debug_print("Found hole at %lx-%lx of size %zx\n", prev_end, procmap[i].begin, sz);
+                tmp = mmap((void*)prev_end, sz, PROT_NONE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
+                debug_print("Got alloc at %p\n", tmp);
+                assert(tmp == (void*)prev_end);
+
+            }
+            prev_end = procmap[i].end;
+        }
+}
+
+/*
+ * Called with new stack, before program main entry, so here we can safely unmap
+ * the old stack.
+ */
+int new_main(int argc, char **argv, char **envp)
+{
+    struct procmap_entry procmap[255];
+    size_t procmap_entries;
+    size_t i;
+    procmap_entries = procmap_parse(procmap, 255);
+    procmap_dump(procmap, procmap_entries);
+    for (i = 0; i < procmap_entries; i++)
+        if (procmap[i].type == PROCMAP_TYPE_STACK) {
+            debug_print("Found old stack mapping: %016lx-%016lx\n",
+                    procmap[i].begin, procmap[i].end);
+/*
+DMITRII KUVAISKII: trying to restrict all access to the new stack which is
+                   already mapped in 32 bits?! Removed it
+
+            mprotect((void*)procmap[i].begin, procmap[i].end - procmap[i].begin,
+                    PROT_NONE);
+*/
+        }
+    procmap_entries = procmap_parse(procmap, 255);
+    procmap_dump(procmap, procmap_entries);
+
+    /* Move thread-local storage (TLS) of glibc. */
+    uintptr_t tlsptr;
+    arch_prctl(ARCH_GET_FS, &tlsptr);
+    debug_print("TLS: %lx [0] = %lx\n", tlsptr, ((unsigned long *)tlsptr)[0]);
+    for (i = 0; i < procmap_entries; i++)
+        if (procmap[i].begin <= tlsptr && procmap[i].end >= tlsptr) {
+            size_t sz = procmap[i].end - procmap[i].begin;
+            debug_print("Found TLS mapping: %016lx-%016lx (%lx)\n",
+                    procmap[i].begin, procmap[i].end, sz);
+
+            void *newtlsmap = mmap(NULL, sz, PROT_READ | PROT_WRITE,
+                    MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
+            assert(newtlsmap != MAP_FAILED);
+            memcpy(newtlsmap, (void*)procmap[i].begin, sz);
+            uintptr_t newtlsptr = (uintptr_t)newtlsmap + (tlsptr - procmap[i].begin);
+            ((unsigned long *)newtlsptr)[0] = (uintptr_t)newtlsptr;
+            arch_prctl(ARCH_SET_FS, (void*)newtlsptr);
+            debug_print("New TLS: %lx\n", newtlsptr);
+            /* Below would be ideal, but internally glibc has ptrs to this
+             * making, for example, printf segfault... */
+            /*mprotect((void*)procmap[i].begin, sz, PROT_NONE);*/
+        }
+
+    __sgxbounds_caninstrument = 1;
+    return orig_main(argc, argv, envp);
+}
+
+int __libc_start_main(int (*main)(int,char **,char **), int argc, char **argv)
+{
+    uintptr_t cur_mmap_base, new_stack_top;
+    uintptr_t new_stack_ptr, new_stack_end, new_argv;
+    size_t alloc_sz;
+    void *tmp, *new_stack;
+    struct rlimit stacklimit;
+
+    debug_print("libpreload.so from shrinkaddrspace for command: '%s'\n",
+            argv[0]);
+
+    if (whitelisted_program(argv[0])) {
+        orig__libc_start_main(main, argc, argv);
+        exit(EXIT_FAILURE);
+    }
+
+    fill_high_holes();
+
+    /* Move mmap_base to 32-bit area by mmap'ing all of the addr space for
+     * ourselves. */
+    cur_mmap_base = (uintptr_t)mmap(NULL, 0x1000, PROT_NONE,
+            MAP_ANONYMOUS | MAP_PRIVATE | MAP_NORESERVE, 0, 0);
+    cur_mmap_base += 0x1000;
+    alloc_sz = cur_mmap_base - REDUCED_ADDRSPACE_SIZE;
+    tmp = mmap(NULL, alloc_sz, PROT_NONE,
+            MAP_ANONYMOUS | MAP_PRIVATE | MAP_NORESERVE, 0, 0);
+    if (tmp == MAP_FAILED) {
+        perror("libc_start_main mmap");
+        fprintf(stderr, "ERROR: Could not mmap required %zx byte of memory for "
+                "address space reduction of '%s', aborting.\n", alloc_sz,
+                argv[0]);
+        exit(1);
+    }
+
+    /* Create a new stack and move all state over to from the original one. */
+    getrlimit(RLIMIT_STACK, &stacklimit);
+    debug_print("rlimit stack: %lx\n", stacklimit.rlim_cur);
+    new_stack = mmap(NULL, stacklimit.rlim_cur, PROT_READ | PROT_WRITE,
+            MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE | MAP_STACK |
+            MAP_GROWSDOWN, 0, 0);
+    new_stack_top = (uintptr_t)new_stack + stacklimit.rlim_cur;
+    setup_new_stack(argv, new_stack_top, &new_stack_ptr,
+            &new_argv);
+
+    /* We will wrap main to unmap the (currently active) old stack and move the
+     * TLS. */
+    orig_main = main;
+
+    debug_print("Calling into orig program now\n");
+
+    {
+        /* Switch stack and call original __libc_start_main, with args (as taken
+           from start.S):
+            main:       %rdi
+            argc:       %rsi
+            argv:       %rdx
+        */
+        __asm__ volatile (
+            "xor   %%rbp, %%rbp \n\t"
+            "movq  %%rax, %%rsp \n\t"
+            "call *%%rbx        \n\t"
+            :
+            : "a"(new_stack_ptr), "b"(orig__libc_start_main),
+              "D"(new_main), "S"(argc), "d"(new_argv));
+    }
+
+    exit(EXIT_FAILURE); /* This is never reached. */
+}
diff --git a/musl-cross-make-master/musl-1.1.14/src/stdio/vfprintf.c b/musl-1.1.14/src/stdio/vfprintf.c
index 2ecf769..b080dcb 100644
--- a/musl-cross-make-master/musl-1.1.14/src/stdio/vfprintf.c
+++ b/musl-1.1.14/src/stdio/vfprintf.c
@@ -126,6 +126,10 @@ union arg
 	void *p;
 };
 
+extern int __sgxbounds_caninstrument;
+static void* dummy_sgxbounds_uninstrument(void* p) { return p; }
+weak_alias(dummy_sgxbounds_uninstrument, __sgxbounds_uninstrument);
+
 static void pop_arg(union arg *arg, int type, va_list *ap)
 {
 	/* Give the compiler a hint for optimizing the switch. */
@@ -154,6 +158,15 @@ static void pop_arg(union arg *arg, int type, va_list *ap)
 	break; case DBL:	arg->f = va_arg(*ap, double);
 	break; case LDBL:	arg->f = va_arg(*ap, long double);
 	}
+
+	// Dmitrii Kuvaiskii: we need to remove any instrumentation
+	// imposed by SGXBounds for any pointer in va_list
+	if (__sgxbounds_caninstrument) {
+		if (type == PTR)
+			arg->p = __sgxbounds_uninstrument(arg->p);
+		if (type == UIPTR)
+			arg->i = (uintptr_t)__sgxbounds_uninstrument((void*)arg->i);
+	}
 }
 
 static void out(FILE *f, const char *s, size_t l)
@@ -363,7 +376,7 @@ static int fmt_fp(FILE *f, long double y, int w, int p, int fl, int t)
 		if (z>d+1) z=d+1;
 	}
 	for (; z>a && !z[-1]; z--);
-	
+
 	if ((t|32)=='g') {
 		if (!p) p++;
 		if (p>e && e>=-4) {
diff --git a/musl-cross-make-master/musl-1.1.14/src/stdio/vfscanf.c b/musl-1.1.14/src/stdio/vfscanf.c
index d4d2454..d5263de 100644
--- a/musl-cross-make-master/musl-1.1.14/src/stdio/vfscanf.c
+++ b/musl-1.1.14/src/stdio/vfscanf.c
@@ -41,6 +41,10 @@ static void store_int(void *dest, int size, unsigned long long i)
 	}
 }
 
+extern int __sgxbounds_caninstrument;
+static void* dummy_sgxbounds_uninstrument(void* p) { return p; }
+weak_alias(dummy_sgxbounds_uninstrument, __sgxbounds_uninstrument);
+
 static void *arg_n(va_list ap, unsigned int n)
 {
 	void *p;
@@ -50,6 +54,12 @@ static void *arg_n(va_list ap, unsigned int n)
 	for (i=n; i>1; i--) va_arg(ap2, void *);
 	p = va_arg(ap2, void *);
 	va_end(ap2);
+
+	// Dmitrii Kuvaiskii: we need to remove any instrumentation
+	// imposed by SGXBounds for any pointer in va_list
+	if (__sgxbounds_caninstrument) {
+		p = __sgxbounds_uninstrument(p);
+	}
 	return p;
 }
 
@@ -108,6 +118,12 @@ int vfscanf(FILE *restrict f, const char *restrict fmt, va_list ap)
 			dest = arg_n(ap, *p-'0'); p+=2;
 		} else {
 			dest = va_arg(ap, void *);
+
+			// Dmitrii Kuvaiskii: we need to remove any instrumentation
+			// imposed by SGXBounds for any pointer in va_list
+			if (__sgxbounds_caninstrument) {
+				dest = __sgxbounds_uninstrument(dest);
+			}
 		}
 
 		for (width=0; isdigit(*p); p++) {
diff --git a/musl-cross-make-master/musl-1.1.14/src/stdio/vfwprintf.c b/musl-1.1.14/src/stdio/vfwprintf.c
index f06d5ae..89e7212 100644
--- a/musl-cross-make-master/musl-1.1.14/src/stdio/vfwprintf.c
+++ b/musl-1.1.14/src/stdio/vfwprintf.c
@@ -117,6 +117,10 @@ union arg
 	void *p;
 };
 
+extern int __sgxbounds_caninstrument;
+static void* dummy_sgxbounds_uninstrument(void* p) { return p; }
+weak_alias(dummy_sgxbounds_uninstrument, __sgxbounds_uninstrument);
+
 static void pop_arg(union arg *arg, int type, va_list *ap)
 {
 	/* Give the compiler a hint for optimizing the switch. */
@@ -145,6 +149,15 @@ static void pop_arg(union arg *arg, int type, va_list *ap)
 	break; case DBL:	arg->f = va_arg(*ap, double);
 	break; case LDBL:	arg->f = va_arg(*ap, long double);
 	}
+
+	// Dmitrii Kuvaiskii: we need to remove any instrumentation
+	// imposed by SGXBounds for any pointer in va_list
+	if (__sgxbounds_caninstrument) {
+		if (type == PTR)
+			arg->p = __sgxbounds_uninstrument(arg->p);
+		if (type == UIPTR)
+			arg->i = (uintptr_t)__sgxbounds_uninstrument((void*)arg->i);
+	}
 }
 
 static void out(FILE *f, const wchar_t *s, size_t l)
diff --git a/musl-cross-make-master/musl-1.1.14/src/stdio/vfwscanf.c b/musl-1.1.14/src/stdio/vfwscanf.c
index 223aad4..c489c04 100644
--- a/musl-cross-make-master/musl-1.1.14/src/stdio/vfwscanf.c
+++ b/musl-1.1.14/src/stdio/vfwscanf.c
@@ -42,6 +42,10 @@ static void store_int(void *dest, int size, unsigned long long i)
 	}
 }
 
+extern int __sgxbounds_caninstrument;
+static void* dummy_sgxbounds_uninstrument(void* p) { return p; }
+weak_alias(dummy_sgxbounds_uninstrument, __sgxbounds_uninstrument);
+
 static void *arg_n(va_list ap, unsigned int n)
 {
 	void *p;
@@ -51,6 +55,12 @@ static void *arg_n(va_list ap, unsigned int n)
 	for (i=n; i>1; i--) va_arg(ap2, void *);
 	p = va_arg(ap2, void *);
 	va_end(ap2);
+
+    // Dmitrii Kuvaiskii: we need to remove any instrumentation
+    // imposed by SGXBounds for any pointer in va_list
+	if (__sgxbounds_caninstrument) {
+	    p = __sgxbounds_uninstrument(p);
+	}
 	return p;
 }
 
@@ -135,6 +145,12 @@ int vfwscanf(FILE *restrict f, const wchar_t *restrict fmt, va_list ap)
 			dest = arg_n(ap, *p-'0'); p+=2;
 		} else {
 			dest = va_arg(ap, void *);
+
+            // Dmitrii Kuvaiskii: we need to remove any instrumentation
+            // imposed by SGXBounds for any pointer in va_list
+			if (__sgxbounds_caninstrument) {
+            	dest = __sgxbounds_uninstrument(dest);
+            }
 		}
 
 		for (width=0; iswdigit(*p); p++) {
